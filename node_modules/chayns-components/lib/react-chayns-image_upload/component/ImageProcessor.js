var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';

import { DomRenderer, ShadowRenderer, utils } from 'pixel-flip';
import timeout from '../utils/timeout';
import ColorFilterList from './lists/ColorFilterList';
import LayerContainer from '../utils/LayerContainer';
import EffectList from './lists/EffectList';
import ImageProcessorMenu from './ImageProcessorMenu';
import Tooltip from '../../react-chayns-tooltip/component/Tooltip';
import canvasToBlob from '../utils/canvasToBlob';
import uploadCloudImage from '../utils/uploadCloudImage';

var MAX_HEIGHT = 2160;

var ImageProcessor = (_temp = _class = function (_Component) {
    _inherits(ImageProcessor, _Component);

    function ImageProcessor() {
        _classCallCheck(this, ImageProcessor);

        var _this = _possibleConstructorReturn(this, (ImageProcessor.__proto__ || Object.getPrototypeOf(ImageProcessor)).call(this));

        _this.state = {
            lastText: ''
        };

        _this.layer = new LayerContainer();
        _this.onSave = _this.onSave.bind(_this);
        _this.onClick = _this.onClick.bind(_this);
        _this.onAddFilter = _this.onAddFilter.bind(_this);
        _this.onRemoveFilter = _this.onRemoveFilter.bind(_this);
        return _this;
    }

    _createClass(ImageProcessor, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            this.initDomRenderer();

            if (this.tooltip) {
                this.tooltip.show();
            }

            window.setTimeout(function () {
                if (_this2.tooltip) {
                    _this2.tooltip.hide();
                }
            }, 5000);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            if (this.lastContainer !== this.container) {
                this.initDomRenderer();
            }
        }
    }, {
        key: 'onSave',
        value: function onSave() {
            var _props = this.props,
                image = _props.image,
                onUpload = _props.onUpload;
            var naturalWidth = image.naturalWidth,
                naturalHeight = image.naturalHeight;


            var width = naturalWidth;
            var height = naturalHeight;
            if (naturalWidth > MAX_HEIGHT || naturalHeight > MAX_HEIGHT) {
                var _utils$dimension$getB = utils.dimension.getBiggerSiteSizing(naturalWidth, naturalHeight, MAX_HEIGHT),
                    newWidth = _utils$dimension$getB.width,
                    newHeight = _utils$dimension$getB.height;

                width = newWidth;
                height = newHeight;
            }

            var renderer = new ShadowRenderer(this.layer.getEnvironment());

            chayns.showWaitCursor().then(timeout(200)).then(function () {
                return renderer.render({
                    width: width,
                    height: height
                });
            }).then(function (canvas) {
                return canvasToBlob(canvas);
            }).then(function (blob) {
                return uploadCloudImage(blob);
            }).then(function (data) {
                if (onUpload) {
                    onUpload(data);
                }

                window.chayns.hideWaitCursor();
            }).catch(function (ex) {
                console.error(ex);
                window.chayns.hideWaitCursor();
            });
        }
    }, {
        key: 'onClick',
        value: function onClick(filterName) {
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var layerInfo = this.layer.getLastLayerInfo();

            if (layerInfo && layerInfo.name === filterName && layerInfo.config === config) {
                this.layer.setFilter(null, config);
            } else {
                this.layer.setFilter(filterName, config);
            }

            this.renderPreview();
            return true;
        }
    }, {
        key: 'onAddFilter',
        value: function onAddFilter(filterName, filterConfig) {
            this.layer.addFilter(filterName, filterConfig);
            this.renderPreview();
        }
    }, {
        key: 'onRemoveFilter',
        value: function onRemoveFilter(filterName) {
            this.layer.removeFilter(filterName);
            this.renderPreview();
        }
    }, {
        key: 'setLayer',
        value: function setLayer(filterName, config) {
            this.layer.setFilter(filterName, config);
            this.renderPreview();
        }
    }, {
        key: 'initDomRenderer',
        value: function initDomRenderer() {
            var _props2 = this.props,
                image = _props2.image,
                maxWidth = _props2.maxWidth,
                maxHeight = _props2.maxHeight;

            var _container$getBoundin = this.container.getBoundingClientRect(),
                containerWidth = _container$getBoundin.width;

            var naturalWidth = image.naturalWidth,
                naturalHeight = image.naturalHeight;

            var _utils$dimension$getF = utils.dimension.getFittingSizing({
                width: naturalWidth,
                height: naturalHeight,
                maxWidth: maxWidth || containerWidth || 600,
                maxHeight: maxHeight || 500
            }),
                width = _utils$dimension$getF.width,
                height = _utils$dimension$getF.height;

            this.domRenderer = new DomRenderer(this.container, this.layer.getEnvironment(), {
                width: width,
                height: height,
                editMode: true
            });
            this.lastContainer = this.container;

            this.layer.addFilter('image', [image, {
                algorithm: 'fit'
            }]);

            this.renderPreview();
        }
    }, {
        key: 'toggleText',
        value: function toggleText() {
            var _this3 = this;

            var lastText = this.state.lastText;


            window.chayns.dialog.input({
                title: 'Gebe bitte deinen Text ein:',
                text: lastText || ''
            }).then(function (data) {
                var filter = _this3.layer.getFilter('text') || _this3.layer.addFilter('text');

                if (data.buttonType === 1) {
                    filter.setText(data.text);
                    filter.setTextColor('#888888');
                    _this3.renderPreview();

                    _this3.setState({
                        lastText: data.text
                    });
                }
            });
        }
    }, {
        key: 'renderPreview',
        value: function renderPreview() {
            this.domRenderer.render({
                editMode: true
            });
            this.forceUpdate();
        }
    }, {
        key: 'renderEditArea',
        value: function renderEditArea() {
            var _this4 = this;

            var _props$image = this.props.image,
                width = _props$image.width,
                height = _props$image.height;


            if (width > MAX_HEIGHT || height > MAX_HEIGHT) {
                return React.createElement(
                    Tooltip,
                    {
                        text: 'Das Bild ist f\xFCr eine Bearbeitung im Browser zu gro\xDF und wird deswegen vor dem Upload verkleinert.',
                        ref: function ref(_ref) {
                            _this4.tooltip = _ref;
                        }
                    },
                    React.createElement('div', {
                        className: 'cc__image-editor__container',
                        ref: function ref(container) {
                            _this4.container = container;
                        }
                    })
                );
            }

            return React.createElement('div', {
                className: 'cc__image-editor__container',
                ref: function ref(container) {
                    _this4.container = container;
                }
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props3 = this.props,
                image = _props3.image,
                onExit = _props3.onExit;


            return React.createElement(
                'div',
                {
                    className: 'cc__image-editor'
                },
                this.renderEditArea(),
                React.createElement(EffectList, {
                    image: image,
                    layer: this.layer,
                    addFilter: this.onAddFilter,
                    removeFilter: this.onRemoveFilter,
                    setLayer: this.onClick,
                    onClick: this.onClick,
                    toggleText: this.toggleText
                }),
                React.createElement(ColorFilterList, {
                    layer: this.layer,
                    image: image,
                    setLayer: this.onClick
                }),
                React.createElement(ImageProcessorMenu, {
                    onSave: this.onSave,
                    onExit: onExit
                })
            );
        }
    }]);

    return ImageProcessor;
}(Component), _class.defaultProps = {
    maxWidth: null,
    maxHeight: null,
    onUpload: null
}, _temp);
export { ImageProcessor as default };