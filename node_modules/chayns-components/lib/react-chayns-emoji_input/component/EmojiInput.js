var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import loadOptionalDependency from '../../utils/loadOptionalDependency';

function requireEmojione(returnPromise) {
    return loadOptionalDependency('emojione', 'emojione', ['https://cdn.jsdelivr.net/npm/emojione@3.1.7/lib/js/emojione.min.js'], ['https://cdn.jsdelivr.net/npm/emojione@3.1.7/extras/css/emojione.min.css'], returnPromise);
}

var EmojiInput = (_temp2 = _class = function (_Component) {
    _inherits(EmojiInput, _Component);

    function EmojiInput() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, EmojiInput);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = EmojiInput.__proto__ || Object.getPrototypeOf(EmojiInput)).call.apply(_ref, [this].concat(args))), _this), _this.lastKeyPressed = null, _this.firstRender = true, _this.activeNode = 0, _this.cursorPos = 0, _this.getActiveChildNode = function () {
            var inputDiv = _this.input;
            var selection = window.getSelection();
            var anchorNode = selection.anchorNode;
            var childNodes = inputDiv.childNodes;

            var activeChildNode = -1;

            if (anchorNode && anchorNode !== inputDiv) {
                for (var i = 0; i < childNodes.length; i += 1) {
                    var curNode = childNodes[i];

                    if (chayns.env.isIOS && curNode.nodeName.toUpperCase() === 'I') {
                        // eslint-disable-next-line prefer-destructuring
                        curNode = curNode.childNodes[0];
                    }

                    if (curNode === anchorNode || curNode.wholeText === anchorNode.wholeText && curNode.nextElementSibling === anchorNode.nextElementSibling && curNode.previousElementSibling === anchorNode.previousElementSibling) {
                        activeChildNode = curNode.nodeType === 1 ? i + 1 : i;
                        break;
                    }
                }
            } else {
                activeChildNode = _this.activeNode;
            }

            return activeChildNode;
        }, _this.setCursorPos = function () {
            var inputDiv = _this.input;
            var _this2 = _this,
                activeNode = _this2.activeNode,
                cursorPos = _this2.cursorPos;


            if (cursorPos > -1) {
                inputDiv.focus();
                var inputChildNodes = inputDiv.childNodes;

                var range = document.createRange();

                if (activeNode > -1) {
                    var cursorNode = inputChildNodes[activeNode];

                    if (cursorNode) {
                        if (cursorNode.nodeType === 1 || cursorNode.length < cursorPos) {
                            var nextSibling = cursorNode.nextSibling ? cursorNode.nextSibling.nextSibling : undefined;

                            if (nextSibling && nextSibling.nodeType === 3) {
                                range.setStart(nextSibling, 0);
                                range.setEnd(nextSibling, 0);
                            } else {
                                var newTextNode = document.createTextNode('');

                                inputDiv.insertBefore(newTextNode, nextSibling);

                                range.setStart(newTextNode, 0);
                                range.setEnd(newTextNode, 0);
                            }
                        } else {
                            range.setStart(cursorNode, cursorPos);
                            range.setEnd(cursorNode, cursorPos);
                        }
                    }
                } else {
                    var _newTextNode = document.createTextNode('');
                    inputDiv.appendChild(_newTextNode);

                    range.setStart(_newTextNode, 0);
                    range.setEnd(_newTextNode, 0);
                }

                var sel = window.getSelection();

                sel.removeAllRanges();
                sel.addRange(range);
            }
        }, _this.getPureInnerText = function (elem) {
            var emojione = requireEmojione(false);

            var textLines = [''];
            var lineIndex = 0;
            var curChild = elem.firstChild;

            var isInDavid = navigator.userAgent.toLowerCase().indexOf('david client') >= 0;

            while (curChild !== null) {
                if (curChild.nodeType === 1) {
                    switch (curChild.tagName) {
                        case 'IMG':
                            textLines[lineIndex] += curChild.getAttribute('alt');
                            break;
                        case 'DIV':
                            textLines.push('');
                            lineIndex += 1;
                            break;
                        case 'BR':
                            if (chayns.env.browser.name.toLowerCase() !== 'chrome' || isInDavid) {
                                textLines[lineIndex] += '\n';
                            }
                            break;
                        default:
                            break;
                    }
                } else if (curChild.nodeType === 3) {
                    textLines[lineIndex] += curChild.nodeValue;
                }

                if (curChild.hasChildNodes()) {
                    curChild = curChild.firstChild;
                } else {
                    while (curChild.nextSibling === null) {
                        curChild = curChild.parentNode;

                        if (curChild === elem) {
                            return textLines.join('\n');
                        }
                    }
                    curChild = curChild.nextSibling;
                }
            }

            if (!emojione) {
                return emojione.shortnameToUnicode(textLines.join('\n'));
            }

            return textLines.join('\n');
        }, _this.handleInput = function (event) {
            var onInput = _this.props.onInput;

            // eslint-disable-next-line no-param-reassign

            event.target.pureInnerText = _this.getPureInnerText(event.target);

            onInput(event);
        }, _this.handleKeyDown = function (event) {
            var onKeyDown = _this.props.onKeyDown;


            _this.lastKeyPressed = event.keyCode;

            if (onKeyDown) {
                onKeyDown(event);
            }
        }, _this.handleKeyUp = function (event) {
            if (chayns.env.browser.name.toLowerCase() === 'ie' && event.keyCode !== 16) {
                _this.handleInput(event);
            }
            if (chayns.env.browser.name.toLowerCase() === 'edge' && event.keyCode === 13 && event.shiftKey) {
                _this.handleInput(event);
            }
        }, _this.handleFocus = function (event) {
            var onFocus = _this.props.onFocus;


            if (onFocus) {
                onFocus(event);
            }
        }, _this.handleBlur = function (event) {
            var onBlur = _this.props.onBlur;


            if (onBlur) {
                onBlur(event);
            }
        }, _this.scrollToCursor = function (scrollTop, scrollHeight) {
            var inputDiv = _this.input;
            var elemScrollHeight = inputDiv.scrollHeight;
            var elemClientHeight = inputDiv.clientHeight;

            if (!(elemScrollHeight <= elemClientHeight)) {
                var diff = elemScrollHeight - scrollHeight;
                _this.input.scrollTop = (scrollTop || 0) + diff;
            }
        }, _this.formatText = function (text) {
            var emojione = requireEmojione(false);

            var result = '';
            var newText = text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/‚Ñ¢/g, '&#153;').replace(/¬©/g, '&copy;').replace(/¬Æ/g, '&reg;').replace(/\(y\)/g, 'üëç').replace(/\(n\)/g, 'üëé');

            if (emojione) {
                newText = emojione.toImage(newText);
            }

            newText = newText.replace(/(<img[^<]*)\/>/g, '$1>').replace(/&#153;/g, '‚Ñ¢').replace(/&copy;/g, '¬©').replace(/&reg;/g, '¬Æ');

            var lines = newText.split('\n');
            var isInDavid = navigator.userAgent.toLowerCase().indexOf('david client') >= 0;

            if (chayns.env.browser.name.toLowerCase() === 'chrome' && !isInDavid) {
                if (lines[lines.length - 1] === '' && _this.lastKeyPressed === 8 && lines.length > 1) {
                    lines[lines.length - 1] = '<br>';
                }

                result = lines.join('\n');
            } else {
                if (lines.length === 1 && chayns.env.browser.name.toLowerCase() === 'edge' && lines[0] === '') {
                    lines[0] = '<br>';
                }

                result = lines.join('<br>');
            }

            return result.replace(String.fromCharCode(160), String.fromCharCode(32)).replace(/&nbsp;/gm, String.fromCharCode(32)).replace(/&amp;/gm, String.fromCharCode(38));
        }, _this.updateDOM = function (newProps) {
            var inputDiv = _this.input;
            var newHtml = _this.formatText(newProps.value);
            var oldHtml = inputDiv.innerHTML.replace(/&nbsp;/gm, String.fromCharCode(32)).replace(/&amp;/gm, String.fromCharCode(38)).replace(String.fromCharCode(160), String.fromCharCode(32));

            if (newHtml !== oldHtml) {
                _this.activeNode = _this.getActiveChildNode();
                var activeElem = inputDiv.childNodes[_this.activeNode];
                if (activeElem) {
                    _this.cursorPos = EmojiInput.getCaretCharacterOffsetWithin(activeElem);

                    var _inputDiv$scrollTop = inputDiv.scrollTop,
                        scrollTop = _inputDiv$scrollTop.scrollTop,
                        scrollHeight = _inputDiv$scrollTop.scrollHeight;


                    inputDiv.innerHTML = newHtml;

                    _this.scrollToCursor(scrollTop, scrollHeight);
                    _this.setCursorPos();
                } else {
                    inputDiv.innerHTML = newHtml;
                }
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(EmojiInput, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            requireEmojione().then(function (emojione) {
                emojione.ascii = true; // eslint-disable-line no-param-reassign
                emojione.imageTitleTag = false; // eslint-disable-line no-param-reassign
                emojione.blacklistChars = '*,#'; // eslint-disable-line no-param-reassign
                emojione.imagePathPNG = 'https://sub54.tobit.com/frontend/assets/emojione/3.1/png/64/'; // eslint-disable-line no-param-reassign
            });
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var _props = this.props,
                placeholder = _props.placeholder,
                disabled = _props.disabled,
                value = _props.value;


            if (nextProps.value.trim() === '') {
                this.placeholder.classList.remove('emoji-input__placeholder--hidden');
            } else {
                this.placeholder.classList.add('emoji-input__placeholder--hidden');
            }

            if (nextProps.placeholder !== placeholder) {
                this.placeholder.innerText = nextProps.placeholder;
            }

            if (nextProps.disabled !== disabled) {
                this.input.contentEditable = !nextProps.disabled;
            }

            if (nextProps.value !== value || this.firstRender) {
                this.updateDOM(nextProps);
                this.firstRender = false;
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _props2 = this.props,
                id = _props2.id,
                hideBorder = _props2.hideBorder,
                disabled = _props2.disabled;


            var messageInputClasses = classNames('emoji-input__message-input', {
                'emoji-input__message-input--hide-border': hideBorder,
                'emoji-input__message-input--disabled': disabled,
                input: !disabled
            });

            return React.createElement(
                'div',
                { className: 'emoji-input' },
                React.createElement('div', {
                    dangerouslySetInnerHTML: { __html: '<br />' },
                    ref: function ref(_ref2) {
                        _this3.input = _ref2;
                    },
                    className: messageInputClasses,
                    onKeyDown: this.handleKeyDown,
                    contentEditable: !disabled,
                    onKeyUp: this.handleKeyUp,
                    onInput: this.handleInput,
                    onFocus: this.handleFocus,
                    onBlur: this.handleBlur,
                    dir: 'auto',
                    id: id
                }),
                React.createElement('div', {
                    className: 'emoji-input__placeholder',
                    ref: function ref(_ref3) {
                        _this3.placeholder = _ref3;
                    }
                })
            );
        }
    }], [{
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate() {
            return false;
        }
    }, {
        key: 'getCaretCharacterOffsetWithin',
        value: function getCaretCharacterOffsetWithin(element) {
            var caretOffset = -1;

            if (typeof window.getSelection !== 'undefined') {
                var sel = window.getSelection();

                if (sel.anchorNode && (sel.anchorNode.nodeType === 3 || !sel.anchorNode.classList.contains('icon-smile-o'))) {
                    var range = sel.getRangeAt(0);
                    var preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(element);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);
                    caretOffset = preCaretRange.toString().length;
                }
            } else if (typeof document.selection !== 'undefined' && document.selection.type !== 'Control') {
                var _sel = document.selection;

                if (_sel.anchorNode && (_sel.anchorNode.nodeType === 3 || !_sel.anchorNode.classList.contains('icon-smile-o'))) {
                    var textRange = document.selection.createRange();
                    var preCaretTextRange = document.body.createTextRange();
                    preCaretTextRange.moveToElementText(element);
                    preCaretTextRange.setEndPoint('EndToEnd', textRange);
                    caretOffset = preCaretTextRange.text.length;
                }
            }
            return caretOffset;
        }
    }]);

    return EmojiInput;
}(Component), _class.defaultProps = {
    hideBorder: false,
    onKeyDown: null,
    disabled: false,
    onFocus: null,
    onBlur: null
}, _temp2);
export { EmojiInput as default };