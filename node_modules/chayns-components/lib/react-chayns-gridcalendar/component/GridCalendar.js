var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable */

import React, { Component } from 'react';
import PropTypes from 'prop-types';

import Navigator from './content/Navigator';
import User from './content/User';
import Groups from './content/Groups';

var WEEK_WIDTH = 50;

var transformLeft = 0,
    transformRight = 0,
    focusWeek = void 0,
    isDesktop = window.innerWidth > 450;

var ProgressCalendar = (_temp = _class = function (_Component) {
    _inherits(ProgressCalendar, _Component);

    _createClass(ProgressCalendar, null, [{
        key: 'dateInterval',
        value: function dateInterval(dateStart, dateEnd) {
            var startDate = dateStart.getDate() < 10 ? '0' + dateStart.getDate() : dateStart.getDate(),
                startMonth = dateStart.getMonth() + 1 < 10 ? '0' + (dateStart.getMonth() + 1) : dateStart.getMonth() + 1,
                endDate = dateEnd.getDate() < 10 ? '0' + dateEnd.getDate() : dateEnd.getDate(),
                endMonth = dateEnd.getMonth() + 1 < 10 ? '0' + (dateEnd.getMonth() + 1) : dateEnd.getMonth() + 1;
            return startDate + '.' + startMonth + ' - ' + endDate + '.' + endMonth + '.' + dateEnd.getFullYear();
        }
    }, {
        key: 'getWeek',
        value: function getWeek(currentStart) {
            var monday = void 0,
                sunday = void 0;
            if (currentStart.getDay() === 0) {
                monday = new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate() - 6);
                sunday = new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate(), 23, 59);
            } else {
                monday = new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate() - (currentStart.getDay() - 1));
                sunday = new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate() + (7 - currentStart.getDay()), 23, 59);
            }
            return [monday, sunday];
        }
    }, {
        key: 'sortEntries',
        value: function sortEntries(entries) {
            if (entries) {
                var temp = entries;
                for (var j = 1; j < temp.length; j++) {
                    var entry = temp[j];
                    var i = j - 1;
                    while (i >= 0 && entry.startTime < temp[i].startTime) {
                        temp[i + 1] = temp[i];
                        i = i - 1;
                    }
                    temp[i + 1] = entry;
                }
                return temp;
            }
        }
    }, {
        key: 'realDay',
        value: function realDay(day) {
            if (day.getDay() === 0) {
                return 6;
            } else {
                return day.getDay() - 1;
            }
        }
    }]);

    function ProgressCalendar() {
        _classCallCheck(this, ProgressCalendar);

        var _this = _possibleConstructorReturn(this, (ProgressCalendar.__proto__ || Object.getPrototypeOf(ProgressCalendar)).call(this));

        _this.state = {
            week: 0,
            focusGroup: null,
            isDesktop: window.innerWidth > 450
        };

        _this.onNavigateLeft = _this.onNavigateLeft.bind(_this);
        _this.onNavigateRight = _this.onNavigateRight.bind(_this);
        _this.onClick = _this.onClick.bind(_this);
        _this.groupOnClick = _this.groupOnClick.bind(_this);
        _this.handleTouchMove = _this.handleTouchMove.bind(_this);
        _this.handleTouchStart = _this.handleTouchStart.bind(_this);
        _this.handleTouchEnd = _this.handleTouchEnd.bind(_this);

        window.addEventListener('orientationchange', function (event) {
            isDesktop = screen.availWidth > 450;
            _this.forceUpdate();
        });
        return _this;
    }

    _createClass(ProgressCalendar, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            this.entries = this.getEntries();
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.setState({
                contentWidth: this.content.clientWidth
            });
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            if (this.state.contentWidth != this.content.clientWidth) {
                this.setState({
                    contentWidth: this.content.clientWidth
                });
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            for (var i in nextProps.data) {
                if (nextProps.data.length != this.props.data.length) {
                    this.entries = this.getEntries(nextProps.data, nextProps.startTime, nextProps.endTime);
                    return true;
                } else {
                    if (nextProps.data[i].entries.length != this.props.data[i].entries.length) {
                        this.entries = this.getEntries(nextProps.data, nextProps.startTime, nextProps.endTime);
                        return true;
                    }
                }
            }
            if (nextProps.columns.length != this.props.columns.length || nextProps.groups.length != this.props.groups.length || nextProps.startTime.getTime() != this.props.startTime.getTime() || nextProps.endTime.getTime() != this.props.endTime.getTime()) {
                this.entries = this.getEntries(nextProps.data, nextProps.startTime, nextProps.endTime);
                return true;
            } else if (nextProps.focus != this.props.focus) {
                return true;
            }
            return true;
        }
    }, {
        key: 'onNavigateLeft',
        value: function onNavigateLeft() {
            this.props.onNavigateLeft(this.weeks[focusWeek + (this.state.week - 1)]);
            this.setState({
                week: this.state.week - 1
            });
            transformLeft++;
        }
    }, {
        key: 'onNavigateRight',
        value: function onNavigateRight() {
            var factor = isDesktop ? 2 : 1;
            var retval = this.weeks[focusWeek + (this.state.week + factor)] ? this.weeks[focusWeek + (this.state.week + factor)] : [];
            this.props.onNavigateRight(retval);
            this.setState({
                week: this.state.week + 1
            });
            transformRight++;
        }
    }, {
        key: 'onClick',
        value: function onClick(event, entry) {
            this.props.onClick({ event: event, selected: entry });
            var dateTime = entry.date.getTime(),
                weekEnd = this.weeks[focusWeek + this.state.week][1],
                buffer = 0;
            if (weekEnd < dateTime) {
                buffer = 1;
            }
            for (var i in this.weeks) {
                if (this.weeks[i][0] <= entry.date.getTime() && this.weeks[i][1] >= entry.date.getTime()) {
                    focusWeek = i - buffer;
                    break;
                }
            }
            this.setState({
                focusGroup: null,
                week: 0
            });
        }
    }, {
        key: 'groupOnClick',
        value: function groupOnClick(event, group) {
            if (this.state.focusGroup === group.id) {
                this.setState({
                    focusGroup: null
                });
            } else {
                this.setState({
                    focusGroup: group.id
                });
            }
        }
    }, {
        key: 'handleTouchStart',
        value: function handleTouchStart(event) {
            this.swipeX = event.touches[0].clientX;
        }
    }, {
        key: 'handleTouchMove',
        value: function handleTouchMove(event) {
            //console.log('ELEMENT',this.calendarMonths.offsetWidth);
            //this.move = -1*(this.swipeX-event.touches[0].clientX);
            //this.calendarMonths.style.transform= `translateX(${-1*(this.swipeX-event.touches[0].clientX)}%)`;

            this.moveSwipeX = event.touches[0].clientX;
        }
    }, {
        key: 'handleTouchEnd',
        value: function handleTouchEnd(leftHidden, rightHidden) {
            if (this.swipeX && this.moveSwipeX) {
                if (this.moveSwipeX >= this.swipeX + 60) {
                    if (!leftHidden) {
                        this.onNavigateLeft();
                    }
                    this.swipeX = null;
                    this.moveSwipeX = null;
                    //this.move=null;
                } else if (this.moveSwipeX <= this.swipeX - 60) {
                    if (!rightHidden) {
                        this.onNavigateRight();
                    }
                    this.swipeX = null;
                    this.moveSwipeX = null;
                }
            }
        }
    }, {
        key: 'getWeeks',
        value: function getWeeks(startTime, endTime) {
            var retval = [],
                currentStart = startTime;
            while (currentStart.getTime() < endTime.getTime()) {
                var _ProgressCalendar$get = ProgressCalendar.getWeek(currentStart),
                    _ProgressCalendar$get2 = _slicedToArray(_ProgressCalendar$get, 2),
                    monday = _ProgressCalendar$get2[0],
                    sunday = _ProgressCalendar$get2[1],
                    mondayTS = monday.getTime(),
                    sundayTS = sunday.getTime();

                if (this.props.focus.getTime() >= mondayTS && this.props.focus.getTime() <= sundayTS) {
                    focusWeek = retval.length;
                }
                retval.push([mondayTS, sundayTS]);
                currentStart = new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate() + 7);
            }
            /* if(retval.length === focusWeek){
                 let lastMonday = new Date(retval[retval.length-1][0]), lastSunday = new Date(retval[retval.length-1][1]);
                 lastMonday.setDate(lastMonday.getDate()+7);
                 lastSunday.setDate(lastSunday.getDate()+7);
                 retval.push([lastMonday.getTime(), lastSunday.getTime()]);
             }*/
            this.weeks = retval;
            return retval;
        }
    }, {
        key: 'getNavigatorDays',
        value: function getNavigatorDays(weekStart, weekEnd) {
            var temp = [],
                i = 0,
                date = new Date(weekStart),
                _ProgressCalendar$get3 = ProgressCalendar.getWeek(new Date(date.getFullYear(), date.getMonth(), date.getDate() + 7)),
                _ProgressCalendar$get4 = _slicedToArray(_ProgressCalendar$get3, 2),
                nextWeekStart = _ProgressCalendar$get4[0],
                nextWeekEnd = _ProgressCalendar$get4[1],
                weekDay = ProgressCalendar.realDay(this.props.focus);

            for (i; i < (isDesktop ? 2 : 1); i++) {
                var days = [],
                    j = 0;
                for (j in this.props.columns.names) {
                    if (i === 0) {
                        days.push({
                            name: this.props.columns.names[j],
                            date: new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + parseInt(j))
                        });
                    } else if (i === 1) {
                        days.push({
                            name: this.props.columns.names[j],
                            date: new Date(nextWeekStart.getFullYear(), nextWeekStart.getMonth(), nextWeekStart.getDate() + parseInt(j))
                        });
                    }
                }
                temp.push(days);
            }
            if (this.props.focus.getTime() >= weekStart && this.props.focus.getTime() <= weekEnd) {
                temp[0][weekDay].selected = true;
            } else if (temp[1] && this.props.focus.getTime() >= nextWeekStart.getTime() && this.props.focus.getTime() <= nextWeekEnd.getTime()) {
                temp[1][weekDay].selected = true;
            }
            return temp;
        }
    }, {
        key: 'getEntries',
        value: function getEntries(data, startTime, endTime) {
            data = data ? data : this.props.data;
            startTime = startTime ? startTime : this.props.startTime;
            endTime = endTime ? endTime : this.props.endTime;

            var convertedEntries = [],
                weeks = this.getWeeks(startTime, endTime),
                i = void 0;
            for (i in data) {
                var entries = ProgressCalendar.sortEntries(data[i].entries),
                    userEntries = [],
                    kIndex = 0,
                    j = void 0;
                if (entries) {
                    for (j in weeks) {
                        var m = 0,
                            weekEntries = [];
                        for (m; m < 7; m++) {
                            var retval = {},
                                k = void 0,
                                _startTime = new Date(weeks[j][0] + m * 24 * 60 * 60 * 1000),
                                _endTime = new Date(_startTime.getTime() + (23 * 60 * 60 * 1000 + 59 * 60 * 1000));

                            _startTime = _startTime.getTime();
                            _endTime = _endTime.getTime();
                            /*console.log('######################');
                             console.log('DAY: ');
                             console.log('Start: ', new Date(startTime), 'Offset: ', new Date(startTime).getTimezoneOffset());
                             console.log('End: ', new Date(endTime));*/
                            for (k = kIndex; k < entries.length; k++) {
                                /**
                                 * Only possible for entries, which are not longer than a day
                                 */
                                /*if(k>4) {
                                 console.log('--------------------------------------');
                                 console.log('ENTRY-START: ', new Date(entries[k].startTime), 'ENTRY-END: ', new Date(entries[k].endTime));
                                 console.log('--------------------------------------');
                                 }*/
                                if (entries[k].startTime >= _startTime && entries[k].endTime <= _endTime) {
                                    var l = void 0;
                                    if (this.props.groups.length > 0) {
                                        var isGrouped = false;
                                        for (l in this.props.groups) {
                                            if (entries[k].groupId === this.props.groups[l].id) {
                                                retval = entries[k];
                                                retval.color = this.props.groups[l].color;
                                                isGrouped = true;
                                                break;
                                            }
                                        }
                                        if (!isGrouped) {
                                            retval = entries[k];
                                        }
                                    } else {
                                        retval = entries[k];
                                    }
                                    retval.date = new Date(_startTime);
                                    retval.user = { id: data[i].id, name: data[i].name };
                                    kIndex = k + 1;
                                } else if (entries[k].endTime > _endTime) {
                                    break;
                                }
                            }
                            //console.log('######################');
                            weekEntries.push(retval.user ? retval : {
                                date: new Date(_startTime),
                                user: { id: data[i].id, name: data[i].name }
                            });
                        }
                        userEntries.push(weekEntries);
                    }
                }
                convertedEntries.push({ entries: userEntries, userId: data[i].id });
            }
            return convertedEntries;
        }
    }, {
        key: 'renderUser',
        value: function renderUser() {
            if (this.content && this.props.data) {
                return React.createElement(
                    'div',
                    { className: 'calendar__content_groups' },
                    this.props.data.map(function (user) {
                        return React.createElement(
                            'div',
                            { className: 'calendar__user ellipsis', key: user.id },
                            user.name
                        );
                    })
                );
            } else {
                return '';
            }
        }
    }, {
        key: 'renderEntries',
        value: function renderEntries() {
            var _this2 = this;

            /**
             * TODO: PROBLEM WITH REF. REF GOT OLD WIDTH
             */
            var focus = this.props.focus,
                wrapperWidth = this.weeks.length * WEEK_WIDTH * (isDesktop ? 1 : 2),
                weekWidth = this.content ? this.state.contentWidth / 2 * (isDesktop ? 1 : 2) : 0;

            var content = this.content ? this.entries.map(function (entries) {
                return React.createElement(User, {
                    entries: entries.entries,
                    groups: _this2.props.groups,
                    key: entries.userId,
                    onClick: _this2.onClick,
                    focus: focus,
                    groupFocus: _this2.state.focusGroup,
                    weekWidth: weekWidth
                });
            }) : '';

            return React.createElement(
                'div',
                { className: 'calendar__content_weeks', ref: function ref(content) {
                        return _this2.content = content;
                    } },
                React.createElement(
                    'div',
                    { className: 'calendar__content_wrapper', style: {
                            width: wrapperWidth + '%',
                            transform: 'translateX(' + -1 * (focusWeek + this.state.week) * weekWidth + 'px)'
                        } },
                    content
                )
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var navText = '',
                weekStart = new Date(),
                weekEnd = new Date(),
                days = void 0;
            if (this.weeks) {
                var _weeks = _slicedToArray(this.weeks[focusWeek + this.state.week], 2);

                weekStart = _weeks[0];
                weekEnd = _weeks[1];

                weekStart = new Date(weekStart);
                weekEnd = new Date(weekEnd);
                if (isDesktop) {
                    var start = weekStart,
                        end = new Date(start.getFullYear(), start.getMonth(), start.getDate() + 13);
                    navText = '' + ProgressCalendar.dateInterval(start, end);
                } else {
                    var _start = weekStart,
                        _end = new Date(_start.getFullYear(), _start.getMonth(), _start.getDate() + 6);
                    navText = '' + ProgressCalendar.dateInterval(_start, _end);
                }
                days = this.getNavigatorDays(weekStart, weekEnd);
            }

            var leftHidden = weekStart.getTime() <= this.props.startTime,
                rightHidden = isDesktop ? new Date(weekEnd.getFullYear(), weekEnd.getMonth(), weekEnd.getDate() + 7).getTime() >= this.props.endTime : weekEnd.getTime() >= this.props.endTime;

            return React.createElement(
                'div',
                { className: 'calendar' },
                React.createElement(
                    'div',
                    { className: 'calendar_header', onTouchMove: this.handleTouchMove, onTouchStart: this.handleTouchStart, onTouchEnd: function onTouchEnd() {
                            return _this3.handleTouchEnd(leftHidden, rightHidden);
                        } },
                    React.createElement(Navigator, {
                        text: navText,
                        onClick: {
                            left: this.onNavigateLeft,
                            right: this.onNavigateRight,
                            day: this.onClick
                        },
                        hidden: {
                            left: leftHidden,
                            right: rightHidden
                        },
                        days: days
                    })
                ),
                React.createElement(
                    'div',
                    { className: 'calendar__content', onTouchMove: this.handleTouchMove, onTouchStart: this.handleTouchStart, onTouchEnd: function onTouchEnd() {
                            return _this3.handleTouchEnd(leftHidden, rightHidden);
                        } },
                    this.renderUser(),
                    this.renderEntries()
                ),
                React.createElement(Groups, {
                    groups: this.props.groups,
                    onClick: this.groupOnClick,
                    focus: this.state.focusGroup
                })
            );
        }
    }]);

    return ProgressCalendar;
}(Component), _class.defaultProps = {
    columns: {
        names: ['Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.', 'So.'],
        highlightedColor: chayns.getSchemeColor()
    },
    groups: [],
    focus: new Date(),
    onNavigateRight: function onNavigateRight() {},
    onNavigateLeft: function onNavigateLeft() {}
}, _temp);
export { ProgressCalendar as default };